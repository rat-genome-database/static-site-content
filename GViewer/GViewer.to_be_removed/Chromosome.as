class Chromosome extends MovieClip {			public var parentObj:Object;	public var chromosome:String;	public var chrSpacing:Number = (Stage.width/13)*.7; // 25;	public var chrWidth:Number = (Stage.width/13)*.3;	public var qtlWidth:Number = 10;	public var _x = 10;	public var _y = (Stage.width/13)*.5;	public var homeX:Number = 0;	public var homeY:Number = 0;	public var qtlPosition:String = "offset";		private var featureList:Array;		public var tmpFeatureArray:Array = new Array();	public var scaleFactor:Number = 1000000;	public var chr_length:Number = 0;	public var isZoomed:String = "no";	public var isRotated:String = "no";	private var featureDrawIndex:Number;	public var tickSpacing:Number = 500000;	public var isHomePosition = Boolean(false);	public var linkURL:String = "";	public var number_txt:Object;		public var bar:BarSelector;		public static function createChromosome(target:MovieClip, depth:Number, x:Number, y:Number, chr:String, linkUrl:String, length:Number):Chromosome {		trace("Chromosome created for: " + chr);		trace("Chromosome attaching to : " + target._name + "Root: " + _root._name);					var chrom:Chromosome = 		Chromosome(target.attachMovie("Chromosome","Chromosome_" + chr + "_" + depth, depth));		chrom.init(target, x, y, chr, linkUrl, length); // initialize the object				return chrom;		}			public function init(target:MovieClip, x:Number, y:Number, chr:String, linkUrl:String, length:Number) {			this.parentObj = target;		this._x = x;		this._y = y;		this.chromosome = chr;		this.linkURL = linkURL;		this.chr_length = length;			this.featureList = new Array();				trace("Chromosome attached " + this._name + " to: " + _parent._name);			}		public function addFeature(feature:Feature):Void {		featureList.push(feature);		trace("Feature added to " +this._name + ", we have " + featureList.length + " features for this chromosome");	}		public function sortFeaturesByType(a:Feature,b:Feature):Number {		var featureType1:String = a.type;		var featureType2:String = b.type;		if(featureType1 < featureType2) {			return -1;		} else if (featureType1 > featureType2) {			return 1;		}		else {			return 0;		}	}			/*public function press(evt:Object):Void {		trace("Detected button press, doing redraw!");		this.drawFeatures(true,true,false);			}	*/	// Stub	function drawFeatures(withLabels:Boolean,inRows:Boolean, showScale:Boolean) {			trace("rendering features for " + this._name);			//trace("rendering features for " + this.chromosome);						if(this.isZoomed == "yes") {				//trace("Chromosome zoomed!" + this._name);				withLabels = _root._labelFeaturesOnZoomView;				inRows = Boolean(false); // If we are zoomed then dont compress			}			else {				//trace("Chromosome not zoomed!" + this._name);				withLabels = _root._labelFeaturesOnGenomeView;			}						this.featureList.sort(this.sortFeaturesByType); // sort the feature list						for (var f = 0; f< this.featureList.length; f++) {				this.featureList[f]._x = this.chrWidth; // return to home position				this.featureList[f].drawFeature(withLabels);			}			this.featureDrawIndex = 0;			// var showScale:Boolean = true;						if(showScale) {				this.lineStyle(1, 0xffffff, 100);								// draw a vertical line the length of the chromosome				/*				this.moveTo(-5,0);				this.lineTo(-5,(this.chr_length/this.scaleFactor) );				*/								// tick marks down the chromosome, spaced every 'tickSpacing' units				/*				for(var tick:Number=0; tick < (this.chr_length/tickSpacing); tick++) {					trace("Tick: " + tick + ", tickSpacing = " + tickSpacing);					this.moveTo(-5, (tick * tickSpacing/this.scaleFactor) );					this.lineTo(-3, (tick * tickSpacing/this.scaleFactor) );				}				*/				//cap the line at the end of the chromosome				//this.moveTo(-5,(this.chr_length/this.scaleFactor));				//this.lineTo(-3,(this.chr_length/this.scaleFactor) ); //new_mc.chr_length/scaleFactor			}									if(_root.animatedPacking) {			if(this.featureList.length != 0 ) {									this.onEnterFrame = function() {				var xIncrement:Number = 2;				//trace("onEnterFrame: rendering " + this._name);				//trace(this._name + "Drawing, num features: " + this.featureList.length);				if(this.featureDrawIndex == this.featureList.length) {					//trace("All features moved, removing onEnterFrame");					delete this.onEnterFrame;				}				var currentFeature:Feature = this.featureList[0];								//trace("Render loop: real array: " + this.featureList.length);				//trace("Render loop: current feature to move: " + currentFeature.label + ", x: " + currentFeature._x);				//trace("Render loop: settings: inRows" + inRows );								// If we are aligning in rows, just move to the appropriate row, as defined by				// a preset _X coordinate. Nice to pass this in from config file to allow				// different arrangements and more types of features.								if(inRows) {					this.featureList[this.featureDrawIndex]._x = this.chrWidth+2;										switch (this.featureList[this.featureDrawIndex].type) {						case "gene":							//this.featureList[this.featureDrawIndex]._x += 5;							break;						case "qtl":							this.featureList[this.featureDrawIndex]._x += 6;							break;						default:							//this.featureList[this.featureDrawIndex]._x += 5;							break;					}					this.featureDrawIndex++;					// delete this.onEnterFrame; // stop here for this feature				}				else {														// past the minimum distance, check for hits with other features					if(this.featureList[this.featureDrawIndex]._x > (this.chrWidth+5) ) {						//trace("x pos ok");						// check hit with all other features in chromosome, except this one						var missAll:Boolean = true;						for(var g=0; g< this.featureList.length; g++) {							// for all the other 							// ignore this feature itself and others that are of different types.&& (this.featureList[this.featureDrawIndex].type == this.featureList[g].type)							if((this.featureList[this.featureDrawIndex]._name != this.featureList[g]._name)  ) {																// if we hit a feature, keep moving right.								if(this.featureList[this.featureDrawIndex].hitTest(this.featureList[g])) {									this.featureList[this.featureDrawIndex]._x += xIncrement;									trace("        " + this.featureList[this.featureDrawIndex].label + " hits " + this.featureList[g].label + ", keep moving");									missAll = false; // still dont miss everything								}								// otherwise, we're past 25px, dont hit any other feaures, stop moving,								else {									//trace("        " + this.featureList[this.featureDrawIndex].label + "misses " + this.featureList[g].label + ", were done");																		// this.featureList.shift(); // remove this feature from the list								}							}						}						if(missAll) {							//this.featureList[this.featureDrawIndex]._x += 3; // add one just to give some spacing							//trace(this.featureList[this.featureDrawIndex].label + "misses everything, were done");							// redraw feature hilites if turned on							this.featureList[this.featureDrawIndex].checkHilites();							this.featureDrawIndex++;							// delete this.onEnterFrame;						}										 					}					// less than 25px, keep moving right					else {												this.featureList[this.featureDrawIndex]._x += xIncrement;						//trace("x pos increase" + this.featureList[0]._x);					}				}				};				}			}		}				public function drawChromosome():Void {							trace("Drawing chromosome");			var new_chr:MovieClip = this.attachMovie("GenericMC", "chr_mask_mc", 100);						new_chr.lineStyle(0, 0x000000, 100);			new_chr.beginFill(0xFFFFFF, 100);			new_chr.drawRect(0, 0, this.chrWidth, this.chr_length/scaleFactor, 5);			new_chr.endFill();			// Black outline of chromosome			var new_chr_outline:MovieClip = this.attachMovie("GenericMC", "chr_outline_mc", 1000);			new_chr_outline.lineStyle(0, 0x000000, 100);			new_chr_outline.drawRect(0, 0, this.chrWidth, this.chr_length/scaleFactor, 5);			new_chr.lineStyle(2, 0x000000, 100);			// Loop through the bands and their positions to create the banding pattern			var bandHolder = this.attachMovie("GenericMC", "band_holder_mc", 50);			var chrBands:Array = _parent.cytoIdeo_chr_ds.currentItem.band;			trace("Bands: "+chrBands.length);			var lastBandLength = 0;				for (var b = 0; b<chrBands.length; b++) {				var bandData:Array = _root.xParse(chrBands[b]);				// trace("XML: " + chrBands[b]);								var bandStart = 0;				if (bandData["start"]>0) {					bandStart = bandData["start"]/scaleFactor;				}								var bandWidth:Number = this.chrWidth;				var bandHeight:Number = (bandData["end"]/scaleFactor)-bandStart;				var bandColor = null;				// if color is defined in the file				if(bandData["color"]) {					bandColor = bandData["color"];				}				var testBand:Band = Band.createBand(bandHolder, bandHolder.getNextHighestDepth(), 5, 12, 1, bandData["name"],this.chromosome, bandData["start"], bandData["end"], bandData["stain"], bandColor,  bandData["link"]);				testBand.drawBand(bandWidth,bandHeight);				testBand._x = 0;				testBand._y = bandStart;								// Probably have to loop through all the bands to set the mask here				lastBandLength = bandData["end"];			}				 bandHolder.setMask(new_chr);		 		 		}				public function zoomIt() {					// this.startDrag(false);			trace("Clicked: " +this._name + ", home x: " + this.homeX + ", home y: " + this.homeY);						this.isHomePosition = !this.isHomePosition;						if(_root.zoomStyle == "rotate") {				this.isRotated = "yes";			}			else {				this.isRotated = "no";			}						// need to move back to home			if(this.isHomePosition == false) {				this.bar._visible = false; // hide on main view				// show all the chromosomes				/*				for (var c = 0; c< chromosomeList.length; c++) {					//trace("Showing " + chromosomeList[c]._name);					chromosomeList[c]._visible = true;				}				*/				_root.showAllChromosomes();								// move to home position				this._x = this.homeX;				this._y = this.homeY;				this._yscale = 100;				this._xscale = 100;								if(_root.zoomStyle == "rotate") {					this._rotation = 0;					this.isRotated = "yes";				}				else {					this.isRotated = "no";				}								// set alpha to dim if no annotations				if(this.featureList.length) {					this._alpha = 100;				}				else {					this._alpha = _root.dimChrAlpha;				}				this.isZoomed = "no";				this.drawFeatures(_root._labelFeaturesOnGenomeView, true, false);			}			else {							if(this.bar == undefined) {					this.bar = BarSelector.createBarSelector(this, this.getNextHighestDepth(), -6, 0, 3, (this.chr_length/this.scaleFactor), "123", this.chr_length);				}				this.bar._visible = true;							// hide the other chromosomes				/*for (var c = 0; c<chromosomeList.length; c++) {					if (this._name != chromosomeList[c]._name) {						//trace("HIding " + chromosomeList[c]._name);						chromosomeList[c]._visible = false;					}				}				*/								_root.hideAllChromosomesButOne(this._name);								this.isZoomed = "yes";				// move to top left.				var newScaleFactor:Number;				// _root.zoomStyle = "rotate";								if(_root.zoomStyle == "rotate") {					/* Rotate it */										var newScaleFactor:Number = (Stage.width/this._height)*90;					this._yscale = newScaleFactor; // make it bigger					this._xscale = newScaleFactor;					this._rotation = -90;					this._x = 15+(this.number_txt._height); // make sure the chromosome number is visible					this._y = Stage.height-35;				}				else {					newScaleFactor = 190;										// base things off the first chromosome length - the longest in theory					// (_root._longestChromosomeLength/this.chr_length)*90;										//newScaleFactor = (Stage.height/this._height)*90;					//newScaleFactor = 					this._yscale = newScaleFactor; // make it bigger					this._xscale = newScaleFactor;										// Move to the top left					this._x = 20;					this._y = 30;																			}								this._alpha = 100;								// Use _labelFeatures to turn labels on or off via prefs.				this.drawFeatures(_root._labelFeaturesOnZoomView, false, false);			}		};		}