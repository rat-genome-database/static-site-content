/** Feature.as** Simon Twigger, 2005* $id$*** Base actionscript class file for a genomic feature for the Flash GViewer* Can render the following features:*	Gene, QTL**/class Feature extends MovieClip {	private var label_internal:String;	public var link:String;	public var chromosome:String	public var start:Number;	public var end:Number;	public var type:String;	public var parentChr:MovieClip;	public var tip:MovieClip;	public var regionHilite:MovieClip;	public var featureLabel:MovieClip;	private static var featureIndex:Number = 0;		public var featureBgColor:Number;		public var hiliteStayOn:Boolean = false;		public static var defaultTransparency:Number = 70;	public static var qtlColor = 0x3738F7;	public static var geneColor = 0xCE3181;	public static var featureBorderColor = 0x555555;			public function Feature (chr:String, startPos:Number, endPos:Number, featureType:String,name:String,linkUrl:String) {		this.label_internal = name;		this.link = linkUrl;		this.chromosome = chr;		this.start = startPos;		this.end = endPos;		this.type = featureType;			}			public static function createFeature(target:MovieClip, depth:Number, x:Number, y:Number, chr:String, startPos:Number, endPos:Number, featureType:String, name:String, linkUrl:String, color:Number):Feature {		trace("Feature created for: " + name);		trace("Feature attaching to : " + target._name);				// create a unique feature name from chromosome, name and depth				var feat:Feature = Feature(target.attachMovie("FeatureSymbol", chr + "_" + featureIndex + "_" + depth, depth));		trace("Feature attached: " + feat._name);		feat.init(target, x, y, chr, startPos, endPos, featureType, name, linkUrl, color);		feat._alpha = defaultTransparency; // set to transparent		featureIndex++;				return feat;	}				public function init(target:MovieClip, x:Number, y:Number, chr:String, startPos:Number, endPos:Number, featureType:String, name:String, linkUrl:String, color:Number):Void {		trace("Feature initialized for: " + name);		this.parentChr = target;		label_internal = name;		this.link = linkUrl;		this.chromosome = chr;		this.start = startPos;		this.end = endPos;		this.type = featureType;		trace("selecting color, root.bandDisplayColor = " + _root.bandDisplayColor);		/*		this.menu = _root.feature_cm;*/				switch (this.type) {			case "qtl":				if ( (color != undefined) && (color.toString() != "<color />")) {					featureBgColor = color;				}				else if(_root.bandDisplayColor) {					featureBgColor = _root.bandDisplayColor;				}				else {					featureBgColor = qtlColor;				}				break;			case "gene":			case "marker":				if ( (color != undefined) && (color.toString() != "<color />")) {					featureBgColor = color;				}				else if(_root.wedgeDisplayColor) {					featureBgColor = _root.wedgeDisplayColor;				}				else {					featureBgColor = geneColor;				}				break;			case "eqtl":				if ( (color != undefined) && (color.toString() != "<color />")) {					featureBgColor = color;				}				else if(_root.wedgeDisplayColor) {					featureBgColor = _root.wedgeDisplayColor;				}				else {					featureBgColor = geneColor;				}																break;			default:			/* Allow the color to be set for any type of thingy */				if ( (color != undefined) && (color.toString() != "<color />")) {					featureBgColor = color;				}				else {					featureBgColor = 0xBBBBBB;				}				break;		}		this._x = x;		this._y = y;				trace("Feature initialized for: " + label_internal + "coords: " + this._x + "," + this._y);		trace("Feature data for: " + label_internal + "start: " + this.start + ", end" + this.end);	}			public function getFeatureLabel():String {		return label_internal;	}		// Returns the size of the Feature in basepairs (or other unit)	public function getFeatureLength():Number {		return (this.end - this.start);	}		public function getChromosomeBins(intervalLength):Array {				var featureBins:Array = new Array();		var startBin:Number = int(this.start / intervalLength)+1;		var endBin:Number = int(this.end / intervalLength)+1;				// trace("Interval: " + intervalLength + ", startBin: " + startBin + ", endBin: " + endBin);				for (var interval = startBin; interval <= endBin; interval++) {			featureBins.push(interval);		}				return featureBins;	}		// provide hyperlinks from features back to designated home page	public function onPress ():Void {				// If the shift key is down, link out to URL		// otherwise turn highlight on/off		// changed the function of shift modifier as I was always linking out		// when I didnt want to. Linking out should be more of a conscious		// effort, not an accident.		if(Key.isDown(Key.SHIFT)) {			// trace("Shiftkey is down, no link! Sound toggle = " + hiliteStayOn);			if(this.link) {				var clickSound = new Sound();				clickSound.attachSound("clickSound2");				clickSound.start();		    	getURL(this.link, _root._featureLinkTarget);	    	}			else {				_root.featureInfo.text = "[No link URL defined in annotation data]";			}		}		else {			hiliteStayOn = !hiliteStayOn;				    }	      	};  	  	// For those situations where people click and drag and leave tooltips  	// lieing around...  	public function onReleaseOutside():Void {  				this.onRollOut();  				  				/*  				tip._alpha = 0;				//delete tip;				tip.unloadMovie();								// remove the hilite unless its toggled to stay on.				if(hiliteStayOn == false) {					regionHilite._alpha = 0;					regionHilite.unloadMovie();				}  			*/  			  	}  	  	public function createHilite() {  	  		// create a box to link the feature to the parent chromosome when the mouse is over				this.createEmptyMovieClip("regionHilite",parentChr.getNextHighestDepth());				var featurePoint:Object = {x:this._x, y:this._y};		var featurePoint2:Object = {x:this._x, y:this._y};		this.localToGlobal(featurePoint);				trace("Global Feature coords: x=" + featurePoint.x + ", y=" + featurePoint.y);				// convert to parent chromosome coordinate space		parentChr.globalToLocal(featurePoint);		trace("Local Feature coords: x=" + featurePoint.x + ", y=" + featurePoint.y);		trace("Parent Chr Width=" + parentChr.chrWidth);				// default highlite alpha should be low to allow other features to be viewed		// however, if its only a narrow line, bump up the alpha to make it more		// visible.		var hiliteAlpha:Number = 20;				// calculate width based on length of feature		// if feature is too small, default to 3px high line		var hiliteWidth = -((this.start - this.end)/parentChr.scaleFactor);		if( hiliteWidth < 1) {			hiliteWidth = 1;			hiliteAlpha = 50; // increase alpha value for narrow line		}						regionHilite.beginFill(featureBgColor, hiliteAlpha);		regionHilite.drawRect(0,0,-(featurePoint.x/2),hiliteWidth,0);		regionHilite.endFill();				regionHilite._x = 0;		regionHilite._y = 0; // featurePoint.y;  	  	  	}		public function onRollOver() {				for (var f = 0; f< this.parentChr.outLinkList.length; f++) {				var linkObject:Object = this.parentChr.outLinkList[f];				// trace("outlist local object: " + linkObject.localFeature.label_internal);				// trace("local object: " + this.label_internal);								// If this feature is				if(linkObject.localFeature.label_internal == this.label_internal) {					this.parentChr.drawLinkLine(linkObject.localFeature, linkObject.remoteFeature, linkObject.color,"dash");				}		}				for (var f = 0; f< this.parentChr.inLinkList.length; f++) {				var linkObject:Object = this.parentChr.inLinkList[f];				// trace("inlist local object: " + linkObject.localFeature.label_internal);				// trace("local object: " + this.label_internal);				if(linkObject.localFeature.label_internal == this.label_internal) {					this.parentChr.drawLinkLine(linkObject.localFeature, linkObject.remoteFeature, linkObject.color,"solid");				}		}				var tip_fmt:TextFormat = new TextFormat();		tip_fmt.bold = false;		tip_fmt.color = 0x33ff33;		tip_fmt.size = 50;				this.useHandCursor = false;		tip = _root.createEmptyMovieClip("tip",_root.getNextHighestDepth());		_root._toolTipArray.push(tip); // Add to the global toop top array				trace("Added to main array: " + _root._toolTipArray.length);				tip.attachMovie("ToolTipSymbol", "ToolTip", 10);		tip.ToolTip._alpha = 0;		tip.ToolTip.message.setTextFormat(tip_fmt); // set text formating				//format the message textfield		tip.ToolTip.message.autoSize=true;		tip.ToolTip.message.border=true;		tip.ToolTip.message.borderColor=0xFFFFFF;		tip.ToolTip.message.background=true;		tip.ToolTip.message.backgroundColor= featureBgColor;						//control the message with the myMessage parameter of the function		tip.ToolTip.message.text = this.type + ": " + this.label_internal;		//position the tooltip on mouse move						tip._y = _root._ymouse-30;		tip._x = _root._xmouse+10;				if(tip._x + tip._width > Stage.width) {			tip._x = Stage.width - tip._width; 		}		this._alpha = 100;				this.createHilite();									this.onMouseMove = function() {			tip._y = _root._ymouse-30;			tip._x = _root._xmouse;						if(tip._x + tip._width > Stage.width) {				tip._x = Stage.width - tip._width; 			}		}				this.onEnterFrame = function() {			// fade in			if (tip.ToolTip._alpha < 100) {				tip.ToolTip._alpha+=8.3;			}			else {				tip.ToolTip._alpha = 100;				delete this.onEnterFrame;			}			updateAfterEvent();		}				_root.featureInfo.text = this.type + ": " + this.label_internal + "(Chr " + this.chromosome + ": " +this.start + "-" + this.end + ")";			}		public function onRollOut() {															// trace("Checking main tool tip array: " + _root._toolTipArray.length);				for(var i=0; i < _root._toolTipArray.length; i++) {					// trace("Removing tool tip" + _root._toolTipArray[i].ToolTip.message.text);					_root._toolTipArray[i].swapDepths(0);					_root._toolTipArray[i].removeMovieClip();				}				_root._toolTipArray = []; // Clear the array now we are doing turning everything off								// clear the link lines				_root.link_layer.clear();				// redraw the lines to features that are selected				_root.checkFeatureLinks();								delete this.onMouseMove();				delete this.onEnterFrame();																// remove the hilite unless its toggled to stay on.				if(hiliteStayOn == false) {					regionHilite._alpha = 0;					regionHilite.removeMovieClip();				}							this._alpha = defaultTransparency;		_root.featureInfo.text = "";	}		public function checkHilites():Void {			if(this.hiliteStayOn == true) {			// delete the old hilite, then create a new one			this.regionHilite._alpha = 0;			this.regionHilite.removeMovieClip();			this.createHilite();		}		else {			// delete the old hilite			this.regionHilite._alpha = 0;			this.regionHilite.removeMovieClip();		}			}		public function drawFeature(withLabels:Boolean):Void {				//trace("Feature: Drawing feature from " + this.start + "to " + this.end);		//trace("Feature: Drawing feature labels are " + withLabels);				if(this.hiliteStayOn == true) {			// delete the old hilite, then create a new one			this.regionHilite._alpha = 0;			this.regionHilite.removeMovieClip();			this.createHilite();		}				if(withLabels) {			featureLabel = this.createEmptyMovieClip("label",this.getNextHighestDepth());			featureLabel._y = 0;			featureLabel._x = 0;			//if(this.type != "qtl") {			//	featureLabel._y = (this.start/this.parentChr.scaleFactor);			//}			featureLabel.attachMovie("LabelSymbol", "label", 10);			featureLabel.label.message.autoSize = "left";			featureLabel.label.message.text = this.label_internal;						if(this.type != "qtl") {				featureLabel._y -= (featureLabel.label._height/2);			}						//featureLabel._x += (1.5*featureLabel.label._width);						if(_root.zoomStyle == "rotate") {				//featureLabel.label._rotation = -180;				// 			}						//trace("Created label: " + featureLabel.label.message.text);		}		else {			//trace("removing clip");			if(featureLabel._name) {			//trace("have name, removing clip");				featureLabel.removeMovieClip(); // remove the movie clip and its label			}		}		if(this.type == "qtl") {									if(this.start <= parentChr.chr_length) {							// reset end point to end of chromosome				if(this.end > parentChr.chr_length) {					//trace("    qtl end out of bounds:" + this.end + " > chr length: " + this.parentChr.chr_length);					this.end = parentChr.chr_length;				}								this.lineStyle(0, featureBorderColor, 100);				this.beginFill(featureBgColor, 100);							var qtlStartX = 0;				var qtlStartY = 0;				var qtlWidth = 3;							//trace("End Coords:" + (this.end)/this.parentChr.scaleFactor);							this.drawRect(qtlStartX,qtlStartY, qtlWidth, (this.end-this.start)/this.parentChr.scaleFactor, 0);				this.endFill();			}		}		else if(this.type == "marker") {									if(this.start <= parentChr.chr_length) {							// reset end point to end of chromosome				if(this.end > parentChr.chr_length) {					//trace("    qtl end out of bounds:" + this.end + " > chr length: " + this.parentChr.chr_length);					this.end = parentChr.chr_length;				}								this.lineStyle(0, featureBorderColor, 100);				this.beginFill(featureBgColor, 100);							var qtlStartX = 0;				var qtlStartY = 0;				var qtlWidth = 1;							//trace("End Coords:" + (this.end)/this.parentChr.scaleFactor);							// this.drawRect(qtlStartX,qtlStartY, qtlWidth, (this.end-this.start)/this.parentChr.scaleFactor, 0);				this.drawRect(qtlStartX,qtlStartY, qtlWidth, 2, 0);				/*				if( (this.start >= 0) && (this.end <= this.parentChr.chr_length)) {				this.lineStyle(0, featureBorderColor, 100);				this.beginFill(featureBgColor, 100);				// this.drawWedge(0,(this.start/this.parentChr.scaleFactor),342,40,5);				this.drawWedge(0,0,170,-40,4);							}				else {					//trace("    wedge out of bounds:" + this.start + " > chr length: " + this.parentChr.chr_length);				}				*/				this.endFill();			}		}		else if(this.type == "eqtl") {						// Need to get start and stop from other features				var start_Feature = Feature(_root.findFeature(this.start));				var end_Feature = Feature(_root.findFeature(this.end));											trace ("End feature: " + end_Feature.label_internal);								// convert local coords to global				var start_point:Object = {x:start_Feature._width/2, y:start_Feature._height/2};				var end_point:Object = {x:end_Feature._width/2, y:end_Feature._height/2};				start_Feature.localToGlobal(start_point);				end_Feature.localToGlobal(end_point);								trace ("Start feature: " + start_Feature.label_internal);				trace ("start global: " + start_point.x + " y: " + start_point.y);								_root.lineStyle(0, featureBorderColor, 100);				_root.moveTo(start_point.x, start_point.y);				_root.curveTo(end_point.x,start_point.y,end_point.x, end_point.y);		}		else {			//trace("Drawing wedge" + this.start + " to " + this.end + ", Chr length: " + this.parentChr.chr_length);			//trace("Y Coords:" + this.start/this.parentChr.scaleFactor);			// only draw feature if its within the bounds of the chromosome			if( (this.start >= 0) && (this.end <= this.parentChr.chr_length)) {				this.lineStyle(0, featureBorderColor, 100);				this.beginFill(featureBgColor, 100);				// this.drawWedge(0,(this.start/this.parentChr.scaleFactor),342,40,5);				this.drawWedge(0,1,342,40,4);						}			else {				//trace("    wedge out of bounds:" + this.start + " > chr length: " + this.parentChr.chr_length);			}		}								}		// Drawing functions were acquired from the MacroMedia Exchange site		public function drawRect(x, y, w, h, cornerRadius):Void {	// ==============	// mc.drawRect() - by Ric Ewing (ric@formequalsfunction.com) - version 1.1 - 4.7.2002	// 	// x, y = top left corner of rect	// w = width of rect	// h = height of rect	// cornerRadius = [optional] radius of rounding for corners (defaults to 0)	// ==============	if (arguments.length<4) {		return;	}	// if the user has defined cornerRadius our task is a bit more complex. :)	if (cornerRadius>0) {		// init vars		var theta, angle, cx, cy, px, py;		// make sure that w + h are larger than 2*cornerRadius		if (cornerRadius>Math.min(w, h)/2) {			cornerRadius = Math.min(w, h)/2;		}		// theta = 45 degrees in radians		theta = Math.PI/4;		// draw top line		this.moveTo(x+cornerRadius, y);		this.lineTo(x+w-cornerRadius, y);		//angle is currently 90 degrees		angle = -Math.PI/2;		// draw tr corner in two parts		cx = x+w-cornerRadius+(Math.cos(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		cy = y+cornerRadius+(Math.sin(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		px = x+w-cornerRadius+(Math.cos(angle+theta)*cornerRadius);		py = y+cornerRadius+(Math.sin(angle+theta)*cornerRadius);		this.curveTo(cx, cy, px, py);		angle += theta;		cx = x+w-cornerRadius+(Math.cos(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		cy = y+cornerRadius+(Math.sin(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		px = x+w-cornerRadius+(Math.cos(angle+theta)*cornerRadius);		py = y+cornerRadius+(Math.sin(angle+theta)*cornerRadius);		this.curveTo(cx, cy, px, py);		// draw right line		this.lineTo(x+w, y+h-cornerRadius);		// draw br corner		angle += theta;		cx = x+w-cornerRadius+(Math.cos(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		cy = y+h-cornerRadius+(Math.sin(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		px = x+w-cornerRadius+(Math.cos(angle+theta)*cornerRadius);		py = y+h-cornerRadius+(Math.sin(angle+theta)*cornerRadius);		this.curveTo(cx, cy, px, py);		angle += theta;		cx = x+w-cornerRadius+(Math.cos(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		cy = y+h-cornerRadius+(Math.sin(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		px = x+w-cornerRadius+(Math.cos(angle+theta)*cornerRadius);		py = y+h-cornerRadius+(Math.sin(angle+theta)*cornerRadius);		this.curveTo(cx, cy, px, py);		// draw bottom line		this.lineTo(x+cornerRadius, y+h);		// draw bl corner		angle += theta;		cx = x+cornerRadius+(Math.cos(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		cy = y+h-cornerRadius+(Math.sin(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		px = x+cornerRadius+(Math.cos(angle+theta)*cornerRadius);		py = y+h-cornerRadius+(Math.sin(angle+theta)*cornerRadius);		this.curveTo(cx, cy, px, py);		angle += theta;		cx = x+cornerRadius+(Math.cos(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		cy = y+h-cornerRadius+(Math.sin(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		px = x+cornerRadius+(Math.cos(angle+theta)*cornerRadius);		py = y+h-cornerRadius+(Math.sin(angle+theta)*cornerRadius);		this.curveTo(cx, cy, px, py);		// draw left line		this.lineTo(x, y+cornerRadius);		// draw tl corner		angle += theta;		cx = x+cornerRadius+(Math.cos(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		cy = y+cornerRadius+(Math.sin(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		px = x+cornerRadius+(Math.cos(angle+theta)*cornerRadius);		py = y+cornerRadius+(Math.sin(angle+theta)*cornerRadius);		this.curveTo(cx, cy, px, py);		angle += theta;		cx = x+cornerRadius+(Math.cos(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		cy = y+cornerRadius+(Math.sin(angle+(theta/2))*cornerRadius/Math.cos(theta/2));		px = x+cornerRadius+(Math.cos(angle+theta)*cornerRadius);		py = y+cornerRadius+(Math.sin(angle+theta)*cornerRadius);		this.curveTo(cx, cy, px, py);	} else {		// cornerRadius was not defined or = 0. This makes it easy.		this.moveTo(x, y);		this.lineTo(x+w, y);		this.lineTo(x+w, y+h);		this.lineTo(x, y+h);		this.lineTo(x, y);	}};/*-------------------------------------------------------------	mc.drawWedge is a method for drawing pie shaped	wedges. Very useful for creating charts. Special	thanks to: Robert Penner, Eric Mueller and Michael	Hurwicz for their contributions.-------------------------------------------------------------*/	public function drawWedge(x, y, startAngle, arc, radius, yRadius):Void {	// ==============	// mc.drawWedge() - by Ric Ewing (ric@formequalsfunction.com) - version 1.3 - 6.12.2002	//	// x, y = center point of the wedge.	// startAngle = starting angle in degrees.	// arc = sweep of the wedge. Negative values draw clockwise.	// radius = radius of wedge. If [optional] yRadius is defined, then radius is the x radius.	// yRadius = [optional] y radius for wedge.	// ==============	// Thanks to: Robert Penner, Eric Mueller and Michael Hurwicz for their contributions.	// ==============	if (arguments.length<5) {		return;	}	// move to x,y position	this.moveTo(x, y);	// if yRadius is undefined, yRadius = radius	if (yRadius == undefined) {		yRadius = radius;	}	// Init vars	var segAngle, theta, angle, angleMid, segs, ax, ay, bx, by, cx, cy;	// limit sweep to reasonable numbers	if (Math.abs(arc)>360) {		arc = 360;	}	// Flash uses 8 segments per circle, to match that, we draw in a maximum	// of 45 degree segments. First we calculate how many segments are needed	// for our arc.	segs = Math.ceil(Math.abs(arc)/45);	// Now calculate the sweep of each segment.	segAngle = arc/segs;	// The math requires radians rather than degrees. To convert from degrees	// use the formula (degrees/180)*Math.PI to get radians.		theta = -(segAngle/180)*Math.PI;	// convert angle startAngle to radians	angle = -(startAngle/180)*Math.PI;	// draw the curve in segments no larger than 45 degrees.	if (segs>0) {		// draw a line from the center to the start of the curve		ax = x+Math.cos(startAngle/180*Math.PI)*radius;		ay = y+Math.sin(-startAngle/180*Math.PI)*yRadius;		this.lineTo(ax, ay);		// Loop for drawing curve segments		for (var i = 0; i<segs; i++) {			angle += theta;			angleMid = angle-(theta/2);			bx = x+Math.cos(angle)*radius;			by = y+Math.sin(angle)*yRadius;			cx = x+Math.cos(angleMid)*(radius/Math.cos(theta/2));			cy = y+Math.sin(angleMid)*(yRadius/Math.cos(theta/2));			this.curveTo(cx, cy, bx, by);		}		// close the wedge by drawing a line to the center		this.lineTo(x, y);	}};}