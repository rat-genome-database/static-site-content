/*Need to pass/get number of chromosomes from parent objectrather than have it hard coded into this file.the scale factor also needs to be calculated more correctly*/class Chromosome extends MovieClip {	public var parentObj:Object;	public var chromosome:String;	public var chrSpacing:Number = 0;	public var chrWidth:Number = 0;	public var qtlWidth:Number = 10;	public var _x = 10;	public var _y = 0;	public var homeX:Number = 0;	public var homeY:Number = 0;	public var qtlPosition:String = "offset";	private var featureList:Array;	private var outLinkList:Array; // list of objects that link out of this chromosome	private var inLinkList:Array; // list of objects that link into this chromosome	public var tmpFeatureArray:Array = new Array();	public var scaleFactor:Number = 1500000;	public var chr_length:Number = 0;	public var isZoomed:String = "no";	public var isRotated:String = "no";	private var featureDrawIndex:Number;	public var tickSpacing:Number = 500000;	public var isHomePosition = Boolean(false);	public var linkURL:String = "";	public var number_txt:Object;	public var bar:BarSelector;	public var trackSeparatorWidth:Number = 5; // Number of pixels that separates different feature type tracks	public var minimumDistance:Number = this.chrWidth+5;		private var textFieldList = new Array();	public static function createChromosome(target:MovieClip, depth:Number, x:Number, y:Number, chr:String, linkUrl:String, length:Number, chrsPerRow:Number):Chromosome {		trace("Chromosome created for: " + chr);		trace("Chromosome attaching to : " + target._name + "Root: " + _root._name);		var chrom:Chromosome = 		Chromosome(target.attachMovie("Chromosome","Chromosome_" + chr + "_" + depth, depth));		chrom.init(target, x, y, chr, linkUrl, length, chrsPerRow); // initialize the object		return chrom;	}	public function init(target:MovieClip, x:Number, y:Number, chr:String, linkUrl:String, length:Number, chrsPerRow:Number) {		this.parentObj = target;		this._x = x;		this._y = y;		this.chromosome = chr;		this.linkURL = linkURL;		this.chr_length = length;			this.featureList = new Array();		this.outLinkList = new Array();		this.inLinkList = new Array();		this.chrSpacing = (Stage.width/chrsPerRow)*.7; // 25;		this.chrWidth = (Stage.width/chrsPerRow)*.3;		// this._y = (Stage.width/chrsPerRow)*.5;				// this.menu = _root.feature_cm;		trace("Chromosome attached " + this._name + " to: " + _parent._name);	}	public function addFeature(feature:Feature):Void {		featureList.push(feature);		trace("Feature added to " +this._name + ", we have " + featureList.length + " features for this chromosome");	}	public function addOutLink(obj:Object):Void {		this.outLinkList.push(obj);		trace("outlink added to " +this._name + ", we have " + this.outLinkList.length + " outlinks for this chromosome");	}	public function addInLink(obj:Object):Void {		this.inLinkList.push(obj);		trace("inlink added to " +this._name + ", we have " + this.inLinkList.length + " inlinks for this chromosome");	}	public function sortFeaturesByType(a:Feature,b:Feature):Number {		var featureType1:String = a.type;		var featureType2:String = b.type;		if(featureType1 < featureType2) {			return -1;			} else if (featureType1 > featureType2) {				return 1;			}			else {				return 0;			}	}		public function sortFeaturesByTypeAndPosition(a:Feature,b:Feature):Number {		var featureType1:String = a.type;		var featureType2:String = b.type;		if(featureType1 < featureType2) {			return -1;			} else if (featureType1 > featureType2) {				return 1;			}			// features the same type so decide on start position			else {				if(a.start < b.start) {					return -1;				}				else if (a.start > b.start) {					return 1;				}				else {					return 0;				}			}	}		public function sortFeaturesBySize(a:Feature,b:Feature):Number {		var length1:Number = a.getFeatureLength();		var length2:Number = b.getFeatureLength();		if(length1 < length2) {			return -1;			} else if (length1 > length2) {				return 1;			}			else {				return 0;			}	}	public function drawLinkLine(startObj,endObj,color,style) {		// convert local coords to global		trace("start width: " + startObj._width);		var start_point:Object = {x:startObj._width, y:startObj._height/2};		if (startObj.hiliteStayOn) {			start_point = {x:0, y:startObj._height/2};		}		var end_point:Object;		startObj.localToGlobal(start_point);		end_point = {x:endObj._width, y:endObj._height/2};		if (endObj.hiliteStayOn) {			end_point = {x:0, y:endObj._height/2};		}		endObj.localToGlobal(end_point);		_root.link_layer.lineStyle(0, color, 75);		// if we are linking to this same chromosome, use a curve, not a line		if((startObj.chromosome == endObj.chromosome) || (Math.abs(start_point.x - end_point.x) < 10) ) {			_root.link_layer.moveTo(start_point.x, start_point.y);			if( (this.isZoomed == "yes") && (startObj.chromosome != endObj.chromosome) ) {				var y_loc = (((Stage.height-30)/_root.chromosomeList.length)*_root.chromosomeNameToIndex[endObj.chromosome])+30;				end_point = {x:Stage.width-30, y:y_loc};				this.polygon(_root.link_layer,Stage.width-30,y_loc,6,10,0); 			}			var control_y:Number;			if(start_point.y < end_point.y) {				control_y = start_point.y + (end_point.y - start_point.y)/2;			}			else {				control_y = end_point.y + (start_point.y - end_point.y)/2;			}			var control_x:Number;			// draw the control point based on the right most feature			if(start_point.x > end_point.x) {				control_x = start_point.x + 30; // arbitrary value for now			}			else {				control_x = end_point.x + 30;			}			_root.link_layer.curveTo(control_x, control_y,end_point.x, end_point.y);		}		else {			if(this.isZoomed == "yes") {				var y_loc = (((Stage.height-30)/_root.chromosomeList.length)*_root.chromosomeNameToIndex[endObj.chromosome])+30;				end_point = {x:Stage.width-30, y:y_loc};				this.polygon(_root.link_layer,Stage.width-30,y_loc,6,10,0);							}			else {				end_point = {x:endObj._width/2, y:endObj._height/2};				endObj.localToGlobal(end_point);			}			trace("Drawing line from: "+ start_point.x + "," + start_point.y + "to: " + end_point.x + "," + end_point.y);			_root.link_layer.lineStyle(0, color, 75);			if(style == "dash") {				this.dashTo(_root.link_layer,start_point.x, start_point.y,end_point.x, end_point.y,3,3,0,color,75);			}			else {				_root.link_layer.moveTo(start_point.x, start_point.y);				_root.link_layer.lineTo(end_point.x, end_point.y);			}		}	}		/**		* dashTo		* Draws a dashed line from the point x1,y1 to the point x2,y2		* The line may is drawn on the movie clips specified by the 		* <em>target</em> parameter (default is _root).  The line may 		* be any color or transparency and width, length of dashes, 		* and space between dashes may all be specified.		* 		* @param target MovieClip the movie clip on which the dashed 		* line will be drawn.		* @param x1 Number starting position on x axis - <strong></strong>required</strong>		* @param y1 Number starting position on y axis - <strong></strong>required</strong>		* @param x2 Number finishing position on x axis - <strong></strong>required</strong>		* @param y2 Number finishing position on y axis - <strong></strong>required</strong>		* @param dashLength [optional] Number the number of pixels long each dash 		* will be.  Default = 5		* @param spaceLength [optional] Number the number of pixels between each 		* dash.  Default = 5		* @param strokWidth [optional] Number the width of each dash. 		* Default = 1		* @param rgbHex [optional] the Hex color value of the dashed line.  		* Default = 0x000000		* @param alpha [optional] Number the alpha transparancy that the dashed 		* line will have. Default = 100;		*/		public function dashTo(target:MovieClip, x1:Number, 			y1:Number,x2:Number, y2:Number, dashLength:Number, 			spaceLength:Number ):Void			{				if ( arguments < 5 ){					trace("com.polymercode.Draw.dashTo - too few parameters.");					return;				}				if ( spaceLength == undefined )				spaceLength = 5;				if ( dashLength == undefined )				dashLength = 5;				var x = x2 - x1;				var y = y2 - y1;				var hyp = Math.sqrt((x)*(x) + (y)*(y));				var units = hyp/(dashLength+spaceLength);				var dashSpaceRatio = dashLength/(dashLength+spaceLength);				var dashX = (x/units)*dashSpaceRatio;				var spaceX = (x/units)-dashX;				var dashY = (y/units)*dashSpaceRatio;				var spaceY = (y/units)-dashY;				target.moveTo(x1, y1);				while (hyp > 0) {					x1 += dashX;					y1 += dashY;					hyp -= dashLength;					if (hyp < 0) {						x1 = x2;						y1 = y2;					}					target.lineTo(x1, y1);					x1 += spaceX;					y1 += spaceY;					target.moveTo(x1, y1);					hyp -= spaceLength;				}				target.moveTo(x2, y2);			}/*** a method for creating polygon shapes.  Negative values will draw * the polygon in reverse direction.  Negative drawing may be useful * for creating knock-outs in masks.* * @param target the MovieClip that the polygon is to be drawn on* @param x x coordinate of the center of the polygon* @param y y coordinate of the center of the polygon* @param sides the number of sides (must be > 2)* @param radius the radius from the center point to the points* on the polygon* @param angle [optional] the starting offset angle (degrees) from* 0. Default = 0* * based on mc.drawPoly() - by Ric Ewing (ric@formequalsfunction.com) - version 1.4 - 4.7.2002*/public function polygon(target:MovieClip, x:Number, 	y:Number, sides:Number, radius:Number, angle:Number):Void 	{		if (arguments.length<5)		{			trace("com.polymercode.Draw.polygon - too few parameters");			return;		}		if ( angle == undefined )		angle = 0;		// convert sides to positive value		var count = Math.abs(sides);		// check that count is sufficient to build polygon		if (count>2) {			// init vars			var step, start, n, dx, dy;			// calculate span of sides			step = (Math.PI*2)/sides;			// calculate starting angle in radians			start = (angle/180)*Math.PI;			target.moveTo(x+(Math.cos(start)*radius), y-(Math.sin(start)*radius));			// draw the polygon			for (n=1; n<=count; n++) {				dx = x+Math.cos(start+(step*n))*radius;				dy = y-Math.sin(start+(step*n))*radius;				target.lineTo(dx, dy);			}		}	}												// drawFeatures lays out the various features on the chromosome				// using a variety of algorithms.				function drawFeatures(withLabels:Boolean,inRows:Boolean, showScale:Boolean) {					trace("rendering features for " + this._name);					//trace("rendering features for " + this.chromosome);					var hitTestMethod:Boolean = Boolean(false);					var binMethod:Boolean = Boolean(true);										if(this.isZoomed == "yes") {						//trace("Chromosome zoomed!" + this._name);						withLabels = _root._labelFeaturesOnZoomView;												// If there are more than 20 features on the chromosome, turn the labels off by default						// to speed up the animation process						if(this.featureList.length > 10) {							withLabels = Boolean(false)						}						inRows = Boolean(false); // If we are zoomed then dont compress					}					else {						//trace("Chromosome not zoomed!" + this._name);						withLabels = _root._labelFeaturesOnGenomeView;					}/*					this.featureList.sort(this.sortFeaturesByType); // sort the feature list*/					this.featureList.sort(this.sortFeaturesByTypeAndPosition); // sort the feature list					for (var f = 0; f< this.featureList.length; f++) {						this.featureList[f]._x = this.chrWidth; // return to home position						this.featureList[f].drawFeature(withLabels);					}					this.featureDrawIndex = 0;										// Initial minimum distance value										var currentMaxDistance = this.chrWidth+5;					var initialType = this.featureList[0].type										if(showScale) {						this.lineStyle(1, 0xffffff, 100);						// draw a vertical line the length of the chromosome						/*						this.moveTo(-5,0);						this.lineTo(-5,(this.chr_length/this.scaleFactor) );						*/						// tick marks down the chromosome, spaced every 'tickSpacing' units						/*						for(var tick:Number=0; tick < (this.chr_length/tickSpacing); tick++) {							trace("Tick: " + tick + ", tickSpacing = " + tickSpacing);							this.moveTo(-5, (tick * tickSpacing/this.scaleFactor) );							this.lineTo(-3, (tick * tickSpacing/this.scaleFactor) );						}						*/						//cap the line at the end of the chromosome						//this.moveTo(-5,(this.chr_length/this.scaleFactor));						//this.lineTo(-3,(this.chr_length/this.scaleFactor) ); //new_mc.chr_length/scaleFactor					}					if(_root.animatedPacking) {						if(this.featureList.length != 0 ) {							var my_date1:Date = new Date();							var start_secs = my_date1.getTime()							trace(my_date1.getSeconds());							this.onEnterFrame = function() {								var xIncrement:Number = 2;								if(this.featureDrawIndex == this.featureList.length) {									//trace("All features moved, removing onEnterFrame");									var my_date:Date = new Date();									var end_secs = my_date.getTime()									trace("Rendering took: "+(end_secs - start_secs)/1000 + " seconds");									delete this.onEnterFrame;								}								var currentFeature:Feature = this.featureList[0];								//trace("Render loop: real array: " + this.featureList.length);								trace("Render loop: current feature to move: " + this.featureList[this.featureDrawIndex].type + ", x: " + this.featureList[this.featureDrawIndex]._x);								//trace("Render loop: settings: inRows" + inRows );								// If we are aligning in rows, just move to the appropriate row, as defined by								// a preset _X coordinate. Nice to pass this in from config file to allow								// different arrangements and more types of features.								if (binMethod) {									var binLength:Number = 5000000;									var numberOfBins = int(this.chr_length/binLength);									var tracks = new Object(); // will have an element for each track (aka Feature Type)									var featureTypeMaxPositions = new Object();									// GO through all features, get bin information and add									for(var f = 0; f < this.featureList.length; f++) {										if(tracks[this.featureList[f].type] == undefined ) {											tracks[this.featureList[f].type] = new Object();											for (var bin=1; bin < numberOfBins; bin++) {												tracks[this.featureList[f].type]["bin_"+bin] = new Array();											}										}										var featureBins = new Array();										featureBins = this.featureList[f].getChromosomeBins(binLength);										// trace(this.featureList[f].type + "Feature in bins from: " + featureBins[0] + " to " + featureBins[featureBins.length-1]);										for(var b=0; b <= featureBins.length; b++) {											tracks[this.featureList[f].type]["bin_"+featureBins[b]].push(this.featureList[f]);										}										this.featureList[f]._visible = false; // hide initially									}									var featureWidths = new Object();									for(var featureType in tracks) {										var maxFeatureDepth = 0;										for (var bin=1; bin < numberOfBins; bin++) {											if(tracks[featureType]["bin_"+bin].length > 0) {												maxFeatureDepth += tracks[featureType]["bin_"+bin].length;												//trace("Set maxfeaturedepth: " + maxFeatureDepth);												if (maxFeatureDepth > featureWidths[featureType] || featureWidths[featureType] == undefined ) {													featureWidths[featureType] = maxFeatureDepth;												}											}											else {												maxFeatureDepth = 0												//trace("Reset maxfeaturedepth: " + maxFeatureDepth);											}										}									}									// Print a quick summary of results									var lastTrackX = 5;									var maxCurrentTrackX = this.chrWidth+5;									var currentTrackX = maxCurrentTrackX;									var currentTrackStartX = maxCurrentTrackX;									var trackOffset = 7;									var trackCount = 1;									var featureWidth:Number = 3;																	for(var featureType in tracks) {										trace("Track for: " + featureType)										currentTrackX = maxCurrentTrackX;										currentTrackStartX = maxCurrentTrackX;										//trace("Max Feature depth: " + featureWidths[featureType])																													for (var bin=1; bin < numberOfBins; bin++) {											// trace("Bin: " + bin + " = " + tracks[featureType]["bin_"+bin].length + " features")											var widthExceeded = Boolean(false); // gets set if we have too many features and exceed window width											var binExceededCount = 0; // keeps track of the number of features off the edge of the screen											var currentBinY = 0;		// keeps track of the current local y coordinate value											var currentBinX = 0;											// If there are features in this bin, go through them and lay them out left to right											if(tracks[featureType]["bin_"+bin].length > 0) {												// Sort the objects by type and position												tracks[featureType]["bin_"+bin].sort(sortFeaturesByTypeAndPosition);												for(var feature=0; feature < tracks[featureType]["bin_"+bin].length; feature++) {													var theFeature = tracks[featureType]["bin_"+bin][feature];													featureWidth = theFeature._width;																																						if(inRows) {														theFeature._x =  this.chrWidth+(trackOffset*trackCount);														theFeature._visible = true;													}													else {														// Check to see if we have exceeded the window width														// If a feature started in a previous bin it will already be visible														// in which case we should not redraw it here, but just increment the 														// counter and move on to the next feature.														if(theFeature._visible) {															// trace (theFeature.getFeatureLabel() + "Is visible, so already plotted, move on!");															if(theFeature._x + theFeature._width > currentTrackX) {																currentTrackX = theFeature._x + theFeature._width;															}															if(theFeature._x + theFeature._width > maxCurrentTrackX) {																maxCurrentTrackX = theFeature._x + theFeature._width;															}															continue;														}																												var currentPoint:Object = {x:(currentTrackX + theFeature._width*3), y:0};														this.localToGlobal(currentPoint);																												if(currentPoint.x > Stage.width) {															trace("max Exceeded!: "+ theFeature.getFeatureLabel() + " stageWidth: "+ Stage.width + "Count: " + binExceededCount);															widthExceeded = true;															binExceededCount++;															continue;														}														else {															currentBinY = theFeature._y;															currentBinX = currentTrackX;															trace("Set x and y: " + currentBinX);														}																												theFeature._x = currentTrackX; 														// trace (theFeature.getFeatureLabel() + " plotted: " + theFeature._x + " currentX: " + currentTrackX)													theFeature._visible = true;														if(theFeature._x + theFeature._width > currentTrackX) {															currentTrackX = theFeature._x + theFeature._width + 1;														}														if(theFeature._x + theFeature._width > maxCurrentTrackX) {															maxCurrentTrackX = theFeature._x + theFeature._width;														}													}												}												// If there are too many features, draw something here...												if(binExceededCount > 0) {													var polyPoint:Object = {x:currentBinX+featureWidth*2, y:currentBinY+(featureWidth/4)};													this.localToGlobal(polyPoint);													var textFieldSize:Number = 15;													var text_field = _root.drawing_layer.createTextField("text_field_"+bin, _root.drawing_layer.getNextHighestDepth(), polyPoint.x-textFieldSize/2,polyPoint.y-textFieldSize/2,textFieldSize*3,textFieldSize);													//_root.drawing_layer.text_field.setTextFormat(text_field_fmt);													//_root.drawing_layer.text_field.autoSize("left");													_root.drawing_layer["text_field_"+bin].text = "+"+binExceededCount;													this.textFieldList.push(_root.drawing_layer["text_field_"+bin]);													// trace("Drawing overflow thingy: "+ polyPoint.x + "and text: " + _root.drawing_layer.text_field.text);													binExceededCount = 0;												}												currentTrackX = this.chrWidth+lastTrackX; // reset back to zero point											}											else {												currentTrackX = this.chrWidth+lastTrackX;												binExceededCount = 0;											}										}										lastTrackX = maxCurrentTrackX;																				trackCount++;									}									delete this.onEnterFrame;								}								else if (hitTestMethod) {									// Hide the feature									this.featureList[this.featureDrawIndex]._visible = false;									// past the minimum distance, check for hits with other features									if(this.featureList[this.featureDrawIndex]._x > minimumDistance ) {										//trace("x pos ok");										// check hit with all other features in chromosome, except this one										var missAll:Boolean = true;										for(var g=0; g< this.featureList.length; g++) {											// for all the other 											// ignore this feature itself and others that are of different types.&& (this.featureList[this.featureDrawIndex].type == this.featureList[g].type)											if((this.featureList[this.featureDrawIndex]._name != this.featureList[g]._name)  ) {												// if we hit a feature, keep moving right.												if(this.featureList[this.featureDrawIndex].hitTest(this.featureList[g])) {													this.featureList[this.featureDrawIndex]._x += xIncrement;													// trace("        " + this.featureList[this.featureDrawIndex].label + " hits " + this.featureList[g].label + ", keep moving");													missAll = false; // still dont miss everything												}												// otherwise, we're past 25px, dont hit any other feaures, stop moving,												else {													//trace("        " + this.featureList[this.featureDrawIndex].label + "misses " + this.featureList[g].label + ", were done");													// this.featureList.shift(); // remove this feature from the list												}											}										}										if(missAll) {											//this.featureList[this.featureDrawIndex]._x += 3; // add one just to give some spacing											trace(this.featureList[this.featureDrawIndex].type + "misses everything, were done. Length: " + this.featureList[this.featureDrawIndex].getFeatureLength());											// redraw feature hilites if turned on											this.featureList[this.featureDrawIndex].checkHilites();											this.featureList[this.featureDrawIndex]._visible = true;											if ( (this.featureList[this.featureDrawIndex]._x + this.featureList[this.featureDrawIndex]._width) > currentMaxDistance) {												currentMaxDistance = this.featureList[this.featureDrawIndex]._x + this.featureList[this.featureDrawIndex]._width;											}											this.featureDrawIndex++;											var featureBins = new Array();											featureBins = this.featureList[this.featureDrawIndex-1].getChromosomeBins(10000000);											trace(this.featureList[featureDrawIndex-1].type + "Feature in bins from: " + featureBins[0] + " to " + featureBins[featureBins.length-1]);											// If we've hit a new type of feature, start these new features											// after the end of the previous set of features											if (this.featureList[featureDrawIndex].type != initialType) {												minimumDistance = currentMaxDistance; // this.featureList[this.featureDrawIndex-1]._x + this.featureList[this.featureDrawIndex-1]._width + trackSeparatorWidth;												initialType = this.featureList[featureDrawIndex].type;												trace(">>>>><<<<<<< New type: " + initialType + ", and new miniumum x: " + minimumDistance)											}											// delete this.onEnterFrame;										}									}									// less than 25px, keep moving right									else {										this.featureList[this.featureDrawIndex]._x = minimumDistance + xIncrement;										//trace("x pos increase" + this.featureList[0]._x);									}								}							};						}					}				}				public function drawChromosome():Void {					trace("Drawing chromosome");					var new_chr:MovieClip = this.attachMovie("GenericMC", "chr_mask_mc", 100);					new_chr.lineStyle(0, 0x000000, 100);					new_chr.beginFill(0xFFFFFF, 100);					new_chr.drawRect(0, 0, this.chrWidth, this.chr_length/scaleFactor, 5);					new_chr.endFill();					// Black outline of chromosome					var new_chr_outline:MovieClip = this.attachMovie("GenericMC", "chr_outline_mc", 1000);					new_chr_outline.lineStyle(0, 0x000000, 100);					new_chr_outline.drawRect(0, 0, this.chrWidth, this.chr_length/scaleFactor, 5);					new_chr.lineStyle(2, 0x000000, 100);					// Loop through the bands and their positions to create the banding pattern					var bandHolder = this.attachMovie("GenericMC", "band_holder_mc", 50);					var chrBands:Array = _parent.cytoIdeo_chr_ds.currentItem.band;					trace("Bands: "+chrBands.length);					var lastBandLength = 0;					for (var b = 0; b<chrBands.length; b++) {						var bandData:Array = _root.xParse(chrBands[b]);						// trace("XML: " + chrBands[b]);						var bandStart = 0;						if (bandData["start"]>0) {							bandStart = bandData["start"]/scaleFactor;						}						var bandWidth:Number = this.chrWidth;						var bandHeight:Number = (bandData["end"]/scaleFactor)-bandStart;						var bandColor = null;						// if color is defined in the file						if(bandData["color"]) {							bandColor = bandData["color"];						}						var testBand:Band = Band.createBand(bandHolder, bandHolder.getNextHighestDepth(), 5, 12, 1, bandData["name"],this.chromosome, bandData["start"], bandData["end"], bandData["stain"], bandColor,  bandData["link"]);						testBand.drawBand(bandWidth,bandHeight);						testBand._x = 0;						testBand._y = bandStart;						// Probably have to loop through all the bands to set the mask here						lastBandLength = bandData["end"];					}					bandHolder.setMask(new_chr);				}				public function zoomIt() {		// this.startDrag(false);		trace("Clicked: " +this._name + ", home x: " + this.homeX + ", home y: " + this.homeY);		this.isHomePosition = !this.isHomePosition;		if(_root.zoomStyle == "rotate") {			this.isRotated = "yes";		}		else {			this.isRotated = "no";		}		// need to move back to home		if(this.isHomePosition == false) {			this.bar._visible = false; // hide on main view			// show all the chromosomes			/*			for (var c = 0; c< chromosomeList.length; c++) {				//trace("Showing " + chromosomeList[c]._name);				chromosomeList[c]._visible = true;			}			*/			_root.showAllChromosomes();			// move to home position			this._x = this.homeX;			this._y = this.homeY;			this._yscale = 100;			this._xscale = 100;			if(_root.zoomStyle == "rotate") {				this._rotation = 0;				this.isRotated = "yes";			}			else {				this.isRotated = "no";			}			// set alpha to dim if no annotations			if(this.featureList.length) {				this._alpha = 100;			}			else {				this._alpha = _root.dimChrAlpha;			}			this.isZoomed = "no";			_root.drawing_layer.clear(); // Clear any drawing that was done on the zoomed view			if(textFieldList.length > 0) {				for(var i=0; i<textFieldList.length;i++) {					trace("Removing text field!" + textFieldList[i]._x);					textFieldList[i].removeTextField();				}			}			textFieldList = new Array();			this.drawFeatures(_root._labelFeaturesOnGenomeView, true, false);			_root.proxy.call("unzoomChromosome",this.chromosome, new Object());		}		else {			if(this.bar == undefined) {				this.bar = BarSelector.createBarSelector(this, this.getNextHighestDepth(), -6, 0, 3, (this.chr_length/this.scaleFactor), "123", this.chr_length);			}			this.bar._visible = true;			_root.hideAllChromosomesButOne(this._name);			this.isZoomed = "yes";			// move to top left.			var newScaleFactor:Number;			// _root.zoomStyle = "rotate";			if(_root.zoomStyle == "rotate") {				/* Rotate it */				var newScaleFactor:Number = (Stage.height/this._height)*90;				this._yscale = newScaleFactor; // make it bigger				this._xscale = newScaleFactor;				this._rotation = -90;				this._x = 15+(this.number_txt._height); // make sure the chromosome number is visible				this._y = Stage.height-35;			}			else {				newScaleFactor = 100;				// base things off the first chromosome length - the longest in theory				// newScaleFactor = (_root._longestChromosomeLength/this.chr_length)*100;				// newScaleFactor = (Stage.height/this._height)*90;				this._yscale = newScaleFactor; // make it bigger				this._xscale = newScaleFactor;				// Move to the top left				this._x = 20;				this._y = 30;			}			this._alpha = 100;			// Use _labelFeatures to turn labels on or off via prefs.			this.drawFeatures(_root._labelFeaturesOnZoomView, false, false);			_root.proxy.call("zoomChromosome",this.chromosome, new Object());		}	};}